## 缓存
### 收益和成本
收益如下：
- 加速读写
- 降低后端负载

成本如下：
- 数据不一致性：缓存层和存储层的数据存在着一定时间窗口的不一致性，时间窗口跟更新策略有关。
- 代码维护成本：加入缓存后，需要同时处理缓存层和存储层的逻辑，增大了开发者维护代码的成本
- 运维成本：以Redis Cluster为例，加入后无形中增加了运维成本。

使用场景基本包含如下两种：
- 开销大的复杂计算：以MySQL为例，一些复杂的操作或计算(如大量联表操作、一些分组计算)，如果
  不加缓存，不但无法满足高并发量，同时也会给MySQL带来巨大的负担
- 请求加速相应：及时查询单条后端数据足够快，那么依然可以使用缓存，以Redis为例，每秒可以完成
  数万次读写，并且提供批量的操作可以优化整个IO链的响应时间

### 缓存更新策略
1. LRU/LFU/FIFO算法剔除
    - 使用场景：剔除算法通常于语缓存使用量超过了预设的最大值的时候，如何对现有数据进行剔除。如
      Redis使用maxmemory-policy这个配置作为内存最大值后对于数据的剔除策略
    - 一致性：要清理哪些数据是由具体算法决定，开发人员只能决定使用哪种算法，所欲数据的一致性
      是最差的
    - 维护成本：算法不需要开发人员自己来实现，通常只需要配置最大maxmemory和对应的策略即可。
      开发人员只需要知道每种算法的含义，选择适合自己的算法即可。
2. 超时剔除
    - 使用场景：超时剔除通过给缓存数据设置过期时间，让其在过期时间后自动删除。如果业务可以容忍一段
      时间内，缓存层数据和存储层数据不一致，那么可以为其设置过期时间。数据过期后，再从数据源
      获取数据
    - 一致性：一段时间窗口内(取决于过期时间长短)存在一致性问题，即缓存数据和真实数据源的
      数据不一致。
    - 维护成本：维护成本不是很高，只需要设置过期时间即可，前提是应用方允许这段时间可能发生的数据不一致
3. 主动更新
    - 使用场景：应用方对于数据的一致性高球高，需要在真实数据更新后，立即更新缓存数据。
      例如可以利用消息系统或者其他方式通知缓存更新
    - 一致性：一致性最高，但是如果更新发生了问题，那么这条数据很可能很长时间不会更新，
      所以建议结合超时剔除一直使用效果会更好
    - 维护成本：维护成本比较高，开发者需要自己来完成更新，并保证更新操作的正确性。
4. 最佳实践
    - 第一执行业务建议配置最大内存和淘汰策略的方式使用
    - 高一致性业务可以结合使用超时剔除和主动更新，这样即使主动更新出了问题，也能保证数据过期时间
      后删除脏数据
      
### 缓存粒度控制
- 通用性：缓存全部数据比部分数据更加通用，但从实际经验看，很长时间内应用只需要几个重要的
  属性。
- 空间占用：缓存全部数据要比部分数据占用更多的空间，可能存在以下问题：
    - 全部数据会造成内存的浪费
    - 全部数据可能每次传输产生的网络流量会比较大，耗时相对较大，在极端情况下会阻塞网络
    - 全部数据的序列化和反序列化CPU开销更大
- 代码维护：全部数据的优势更加明显，而部分数据一旦要加新字段需要修改业务代码，而且修改后
  通常还需要刷新缓存数据
  
### 穿透优化
缓存穿透指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常处于容错的考虑，如果从
存储层查不到数据则不写入缓存。

#### 解决方案
- 缓存空对象：存储层不命中仍然将空对象保留到缓存层，但是会有两个问题
    - 空值做了缓存，意味着缓存中存了更多的键，需要更多的内存空间(如果是攻击，问题更严重),
      比较有效的方法时针对这类数据设置一个比较短的过期时间，让其自动剔除
    - 缓存层和存储层会有一段时间窗口的不一致，可能会对业务有一定的影响，可以利用消息系统
      或者其他方式清除缓存层中的空对象
- 布隆过滤器拦截：在访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来，做第一层拦截。
    [可利用Redis的bitmaps实现](https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter)    
    
### 无底洞优化
问题分析
- 客户端一次操作会涉及多次网络操作(如一次mget会访问多个Redis节点)，也就意味着批量操作
  会随着节点的增多，耗时会不断增大
- 网络连接数变多，对接点的性能也有一定的影响

结合Redis Cluster的一些特性对四种分布式批量操作的说明
##### 串行命令
由于n个key是均匀分布在Redis Cluster的各个节点上，因此无法使用mget命令一次获取，
所以通常来将要获取n个key的值，最简单的方法就是主次执行n个get命令，这种方式时间复杂度高，
操作时间=n次网络时间+n次命令时间，这种方案不是最优，但是实现简单

##### 串行I/O
将不同的节点的key进行归档，得到每个节点的key的子列表，之后对每个节点执行Pipeline或mget，
效果比第一种好，但如果节点太多，还是有性能问题

##### 并行I/O
将第二种方案的最后一步Pipeline的执行改成多线程执行，这种方案会增加变成复杂度，操作时间为
(max_slow(node 网络时间)) + n次命令时间

##### hash_tag
Redis Cluster的hash_tag功能，可以将多个key强制分配到一个几点上

##### 四种方案比较

方案 | 优点 | 缺点 | 网络IO
:---: | :---: | :---: | :---:
串行命令 | 1）编程简单<br>2）如果少量key，性能可以满足要求 | 大量key请求延迟严重 | O(keys)
串行IO | 1）编程简单<br>2）少量节点性能满足要求 | 大量节点延迟严重 | O(nodes)
并行IO | 利用并行特性，延迟取决于最慢的节点| 1）编程复杂<br>2）由于多线程，问题定位可能比较难 | O(max_slow(nodes))
hash_tag | 性能最高 | 1）业务维护成本较高<br>2）容易出现数据倾斜 | O(1)

### 缓存雪崩
由于缓存承载着大量请求，有效的保护了存储层，但是如果缓存由于某些原因不能提供服务，于是所有
请求都会到达存储层，存储层调用量会暴增，造成存储层也会级联宕机的情况。预防和解决可以从三个方面
着手：
- 保证缓存层服务高可用性，如Sentinel和Cluster都实现了高可用性
- 依赖隔离组件为后端限流并降级
- 提前演练

### 热点key重建优化
开发人员使用"缓存+过期时间"的策略即可以加速数据读写，有保证数据的定期更新，这种模式能
满足绝大部分需求。但是有两个问题如果同时出现，可能就会对应用造成致命的危害：
- 当前key是一个热点key(例如是一个热门的娱乐新闻)，并发量非常大
- 重建缓存不能在短时间完成，可能是一个复杂的计算，如复杂SQL、多次IO、多个依赖等

解决这个问题不复杂，但是不能为了解决这个问题给系统带来更多的麻烦，所以制定如下目标：
- 减少重建缓存次数
- 数据尽可能一致
- 减少潜在危险

#### 互斥锁
只允许一个线程重建缓存，其他线等等待重建缓存的线程执行完，重新从缓存获取数据。
可以使用Redis的setnx命令，获得锁的进行重建，没有获得锁的等待一定时间重新调用

#### 永远不过期
两层意思
- 从缓存层面来看，确实没有设置过期时间，所欲不会出现热点key过期后产生的问题，
  也就是物理不过期
- 从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，
  使用单独的线程去构建缓存。
  
解决方案 | 优点 | 缺点
:---: | :---: | :---:
简单分布式锁 | 思路简单<br>保证一致性 | 代码复杂度增大<br>存在死锁风险<br>存在线程池阻塞的风险
永远不过期 | 基本杜绝热点key问题 | 不保证一致性<br>逻辑过期时间增加代码维护成本和内存成本